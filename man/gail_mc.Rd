% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gail_mc.r
\name{gail_mc}
\alias{gail_mc}
\title{Monte Carlo Estimation of Variability from GAIL}
\usage{
gail_mc(sp_units, cases, suid, num_cases, max_dist, RAP = gail_rap,
  unit_value = "m", spat_fun, nsim = 10, seed = NULL, ...)
}
\arguments{
\item{sp_units}{Data frame of regular spatial units.}

\item{cases}{Data frame containing the the cases.}

\item{suid}{Column name in both \code{cases} which contains the spatial unit identification / name.}

\item{num_cases}{Column name from \code{cases} containing the number of cases, see details.}

\item{max_dist}{The maximum distance at which two locations can be considered neighbors.}

\item{RAP}{Function to be used for calculating assignment probabilities, see details.}

\item{unit_value}{The units of distance, default to meters. See \link[units:set_units]{units::set_units}.}

\item{spat_fun}{A function to compute the statistic of interest over the spatial units. Can also accept
"moran", "localmoran", and "localmoran_full".}

\item{nsim}{The number of Monte Carlo replications to run.}

\item{seed}{If given, sets the seed for the RNG.}

\item{...}{Space for additional arguments (e.g., for \link{gail}).}
}
\value{
The return format depends on the nature of the output of \code{spat_fun}.
\itemize{
\item If \code{spat_fun} returns a scaler, \code{gail_mc} returns a vector.
\item If \code{spat_fun} returns a vector, \code{gail_mc} returns an array.
\item If \code{spat_fun} returns an array, \code{gail_mc} returns a list.
}
}
\description{
For a specified statistic, performs a monte carlo simulation to obtain a distribution based on
repeated allocation using \link{gail}.
}
\details{
Most of the arguments are passed to the \link{gail} arguments of the same names. They are included
(instead of using \code{...}) to facilitate understanding this function.

The \code{spat_fun} argument performs some computation on the dataset. Currently built-in options are:
\itemize{
\item \code{spat_fun = "moran"} will compute Moran's I using \code{spdep::moran}.
\item \code{spat_fun = "localmoran"} will compute the local Moran's I for each spatial unit using
\code{spdep::localmoran} and return the vector of local Moran's I.
\item \code{spat_fun = "localmoran_full"} will return the full results of \code{spdep::localmoran}.
}

The monte carlo simulation repeatedly re-allocates the cases to the regular
spatial units. For each allocation, the result from the argument \code{spat_fun} is saved. This could
be a scaler (e.g., Moran's I), a vector (e.g. local Moran's I), or something more complex.

A custom function for \code{spat_fun} should take the arguments:
\itemize{
\item \code{dat_values} is a vector of numeric data representing the value (number of cases) for each spatial unit
\item \code{nghb_list} is the neighborhood matrix, e.g. as returned by \code{spdep::nb2listw}
\item \code{...} for extra arguments.
For example, the code of \code{spat_fun} for Moran's I is: yyy
}\preformatted{   spat_fun <- function( dat_values, nghb_list, ... ){
       spdep::moran( x     = dat_values,
                     listw = nghb_list,
                     n     = length(dat_values),
                     S0    = spdep::Szero(nghb_list), ...)$I
    }
}
}
\seealso{
\link{gail}
}
